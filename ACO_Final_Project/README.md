# Algorithm Analysis Project Instructions
**Course: Analysis of Algorithms**

## Objective
Investigate an assigned algorithm’s theory, implementation, and real-world impact while demonstrating mastery of computational complexity and problem-solving rigor (aligned with Seoul Accord standards).

---

## CLOs and Seoul Accord Attributes

| **Seoul Accord Attribute** | **Project Task** | **CLO Mapped** | **Bloom’s Level** |
|----------------------------|------------------|----------------|-------------------|
| 1. Conflicting requirements | Optimize for time (polynomial-time approx.) and space (memory constraints) in NP-Hard problems. | 3.1, 6.1 | Apply, Create |
| 2. Depth of analysis | Prove NP-Completeness of a chosen problem via reduction; justify approximation trade-offs. | 2.1, 4.1, 5.1 | Understand, Analyze |
| 3. Depth of knowledge | Implement two distinct design paradigms (e.g., Greedy + DP) and compare analytically. | 3.1, 6.1 | Apply, Create |
| 4. Unfamiliar issues | Address a problem with no known optimal solution (e.g., novel graph traversal scenario). | 6.1 | Create |
| 5. Beyond standard practice | Propose a hybrid approach (e.g., metaheuristics) for a problem outside textbook examples. | 6.1 | Create |
| 6. Stakeholder diversity | Simulate constraints from multiple stakeholders (e.g., cost vs. speed in logistics). | 3.1 | Apply |
| 7. Significant consequences | Analyze societal impact (e.g., bias in algorithmic decisions or energy efficiency). | 5.1 | Evaluate |
| 8. Interdependence | Decompose problem into sub-problems (e.g., use D&C for sorting + DP for optimization). | 4.1, 6.1 | Analyze, Create |
| 9. Ill-defined requirements | Refine problem scope iteratively (e.g., adjust input constraints based on empirical results). | 3.1, 5.1 | Apply, Evaluate |

---

## Course Learning Outcomes (CLOs) & Bloom’s Taxonomy

| **Code #** | **Bloom’s Level** | **Course Learning Outcome (CLO)** | **Seoul Accord Alignment** |
|------------|-------------------|-----------------------------------|----------------------------|
| 2.1        | Understand        | Explain P, NP, NPC, NPH problems, NP-Completeness, and approximation techniques. | Attributes #2, #3 (Depth of analysis/knowledge) |
| 3.1        | Apply             | Implement algorithms, compare empirical performance, and solve real-world problems. | Attributes #1, #6 (Conflicting needs/stakeholders) |
| 4.1        | Analyze           | Analyze time/space complexity of recursive/non-recursive algorithms. | Attributes #2, #4 (Depth/unfamiliar issues) |
| 4.2        | Analyze           | Discuss asymptotic notations (Big-O, Ω, Θ), complexity classes, and function representations. | Attributes #3, #8 (Knowledge/interdependence) |
| 5.1        | Evaluate          | Compare/solve algorithmic problems (Sorting, Searching, Graphs). | Attributes #5, #7 (Beyond standards/consequences) |
| 6.1        | Create            | Design algorithms using Brute Force, D&C, DP, and Greedy techniques. | Attributes #8, #9 (Interdependence/ill-defined) |

---

## Project Overview
Each student will:
1. Research an assigned algorithm (e.g., Dijkstra’s, Knapsack DP, Merge Sort).
2. Implement it in code (Python/C++/Java).
3. Analyze its time/space complexity theoretically and empirically.
4. Document its real-world applications and limitations.
5. Present findings to the class.

**Deliverables**: GitHub repository + report + presentation.

---

## Step-by-Step Tasks

### Phase 1: Algorithm Study (Aligns with CLO 2.1, 4.2)
- Read academic sources/textbooks to understand:
    - How it works: Step-by-step pseudocode/flowchart.
    - Mathematical basis: Recurrence relations, invariants, or proofs (e.g., NP-Completeness for TSP).
- **Seoul Accord Focus**: Attribute #2 (Depth of analysis), #3 (Depth of knowledge).

### Phase 2: Implementation (Aligns with CLO 3.1, 6.1)
- Write clean, modular code with:
    - Input/output specifications.
- **Seoul Accord Focus**: Attribute #1 (Conflicting requirements), #6 (Stakeholders).

### Phase 3: Complexity Analysis (Aligns with CLO 4.1, 4.2)
- Derive theoretical complexity (e.g., O(V+ E log V) for Dijkstra’s).
- Benchmark empirical runtime.
- **Seoul Accord Focus**: Attribute #4 (Unfamiliar issues), #8 (Interdependence).

### Phase 4: Real-World Application (Aligns with CLO 5.1)
- Identify a use case (e.g., Knapsack DP for resource allocation in disaster relief).
- Discuss trade-offs (e.g., accuracy vs. speed in approximations).
- **Seoul Accord Focus**: Attribute #7 (Consequences), #9 (Ill-defined requirements).

### Phase 5: Report & Presentation (Aligns with CLO 5.1, 6.1)
- **Report Sections**:
    1. Introduction: Algorithm purpose.
    2. Methodology: Code design, complexity analysis.
    3. Applications: Real-world scenario + ethical considerations.
    4. Limitations: When the algorithm fails (e.g., Dijkstra’s with negative weights).
- **Presentation**: 10-minute summary with slides + live demo.

---

## Conclusion
 - This project aims to deepen your understanding of algorithms, their complexities, and real-world implications. By following the outlined steps, you will not only learn about a specific algorithm but also develop critical thinking and problem-solving skills essential for a career in computer science.

---
